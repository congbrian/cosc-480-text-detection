# -*- coding: utf-8 -*-
"""extract_bino_cplex

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/191CcxZrNeYTCjCRqlDDC8N5EQ4t9waE5
"""

# Commented out IPython magic to ensure Python compatibility.
!git clone https://github.com/ahans30/Binoculars.git
# %cd Binoculars
!pip install -e .

import numpy as np
import torch
import transformers
import pickle as pkl
import torch.nn.functional as F
from typing import Union
import os
import numpy as np
from transformers import AutoModelForCausalLM, AutoTokenizer
import json

device = 'cuda:0'
torch.cuda.memory._record_memory_history()  # Initialize memory history

from transformers import AutoTokenizer


def assert_tokenizer_consistency(model_id_1, model_id_2):
    identical_tokenizers = (
            AutoTokenizer.from_pretrained(model_id_1).vocab
            == AutoTokenizer.from_pretrained(model_id_2).vocab
    )
    if not identical_tokenizers:
        raise ValueError(f"Tokenizers are not identical for {model_id_1} and {model_id_2}.")

def entropy(p_logits: torch.Tensor,
            q_logits: torch.Tensor,
            encoding: transformers.BatchEncoding,
            pad_token_id: int,
            median: bool = False,
            sample_p: bool = False,
            temperature: float = 1.0):
    vocab_size = p_logits.shape[-1]
    total_tokens_available = q_logits.shape[-2]
    p_scores, q_scores = p_logits / temperature, q_logits / temperature

    p_proba = softmax_fn(p_scores).view(-1, vocab_size)

    if sample_p:
        p_proba = torch.multinomial(p_proba.view(-1, vocab_size), replacement=True, num_samples=1).view(-1)

    q_scores = q_scores.view(-1, vocab_size)

    ce = ce_loss_fn(input=q_scores, target=p_proba).view(-1, total_tokens_available)
    padding_mask = (encoding.input_ids != pad_token_id).type(torch.uint8)

    if median:
        ce_nan = ce.masked_fill(~padding_mask.bool(), float("nan"))
        en_walk = ce_nan.to("cpu").float().numpy()
        agg_ce = np.nanmedian(ce_nan.cpu().float().numpy(), 1)
    else:
        agg_ce = (((ce * padding_mask).sum(1) / padding_mask.sum(1)).to("cpu").float().numpy())

    return agg_ce

def perplexity(encoding: transformers.BatchEncoding,
               logits: torch.Tensor,
               median: bool = False,
               temperature: float = 1.0):
    shifted_logits = logits[..., :-1, :].contiguous() / temperature
    # print(shifted_logits)
    shifted_labels = encoding.input_ids[..., 1:].contiguous()
    # print(shifted_labels)
    shifted_attention_mask = encoding.attention_mask[..., 1:].contiguous()
    # print(shifted_attention_mask)
    if median:
        ce_nan = (ce_loss_fn(shifted_logits.transpose(1, 2), shifted_labels).
                  masked_fill(~shifted_attention_mask.bool(), float("nan")))
        # print(ce_nan)
        walk = ce_nan.to("cpu").float().numpy()
        # print(walk)
        ppl = np.nanmedian(ce_nan.cpu().float().numpy(), 1)

    else:
        ppl = (ce_loss_fn(shifted_logits.transpose(1, 2), shifted_labels) *
               shifted_attention_mask).sum(1) / shifted_attention_mask.sum(1)
        ppl = ppl.to("cpu").float().numpy()

    return ppl

torch.set_grad_enabled(False)

huggingface_config = {
    # Only required for private models from Huggingface (e.g. LLaMA models)
    "TOKEN": os.environ.get("HF_TOKEN", None)
}

# selected using Falcon-7B and Falcon-7B-Instruct at bfloat16
BINOCULARS_ACCURACY_THRESHOLD = 0.9015310749276843  # optimized for f1-score
BINOCULARS_FPR_THRESHOLD = 0.8536432310785527  # optimized for low-fpr [chosen at 0.01%]

DEVICE_1 = "cuda:0" if torch.cuda.is_available() else "cpu"
DEVICE_2 = "cuda:1" if torch.cuda.device_count() > 1 else DEVICE_1

class Binoculars(object):
    def __init__(self,
                 observer_name_or_path: str = "tiiuae/falcon-7b",
                 performer_name_or_path: str = "tiiuae/falcon-7b-instruct",
                 use_bfloat16: bool = True,
                 max_token_observed: int = 512,
                 mode: str = "low-fpr",
                 ) -> None:
        assert_tokenizer_consistency(observer_name_or_path, performer_name_or_path)

        self.change_mode(mode)
        self.observer_model = AutoModelForCausalLM.from_pretrained(observer_name_or_path,
                                                                   device_map={"": DEVICE_1},
                                                                   trust_remote_code=True,
                                                                   torch_dtype=torch.bfloat16 if use_bfloat16
                                                                   else torch.float32,
                                                                   token=huggingface_config["TOKEN"]
                                                                   )
        self.performer_model = AutoModelForCausalLM.from_pretrained(performer_name_or_path,
                                                                    device_map={"": DEVICE_2},
                                                                    trust_remote_code=True,
                                                                    torch_dtype=torch.bfloat16 if use_bfloat16
                                                                    else torch.float32,
                                                                    token=huggingface_config["TOKEN"]
                                                                    )
        self.observer_model.eval()
        self.performer_model.eval()

        self.tokenizer = AutoTokenizer.from_pretrained(observer_name_or_path)
        if not self.tokenizer.pad_token:
            self.tokenizer.pad_token = self.tokenizer.eos_token
        self.max_token_observed = max_token_observed

    def change_mode(self, mode: str) -> None:
        if mode == "low-fpr":
            self.threshold = BINOCULARS_FPR_THRESHOLD
        elif mode == "accuracy":
            self.threshold = BINOCULARS_ACCURACY_THRESHOLD
        else:
            raise ValueError(f"Invalid mode: {mode}")

    def _tokenize(self, batch: list[str]) -> transformers.BatchEncoding:
        batch_size = len(batch)
        encodings = self.tokenizer(
            batch,
            return_tensors="pt",
            padding="longest" if batch_size > 1 else False,
            truncation=True,
            max_length=self.max_token_observed,
            return_token_type_ids=False).to(self.observer_model.device)
        return encodings

    @torch.inference_mode()
    def _get_logits(self, encodings: transformers.BatchEncoding) -> torch.Tensor:
        observer_logits = self.observer_model(**encodings.to(DEVICE_1)).logits
        performer_logits = self.performer_model(**encodings.to(DEVICE_2)).logits
        if DEVICE_1 != "cpu":
            torch.cuda.synchronize()
        return observer_logits, performer_logits

    def compute_score(self, input_text: Union[list[str], str], verbose=False) -> Union[float, list[float]]:
        batch = [input_text] if isinstance(input_text, str) else input_text
        encodings = self._tokenize(batch)
        observer_logits, performer_logits = self._get_logits(encodings)
        ppl = perplexity(encodings, performer_logits)
        x_ppl = entropy(observer_logits.to(DEVICE_1), performer_logits.to(DEVICE_1),
                        encodings.to(DEVICE_1), self.tokenizer.pad_token_id)
        binoculars_scores = ppl / x_ppl
        binoculars_scores = binoculars_scores.tolist()
        ppl = perplexity(encodings, performer_logits)
        x_ppl = entropy(observer_logits, performer_logits, encodings, bino.tokenizer.pad_token_id)
        del encodings
        del observer_logits
        del performer_logits
        torch.cuda.empty_cache()
        if verbose == True:
          print("Perplexity (compute_score):", ppl)
          print("Entropy (compute_score):", x_ppl)
          print("Binoculars Score (compute_score):", ppl / x_ppl)
        return binoculars_scores[0] if isinstance(input_text, str) else binoculars_scores

    def predict(self, input_text: Union[list[str], str], verbose=False) -> Union[list[str], str]:
        binoculars_scores = np.array(self.compute_score(input_text))
        pred = np.where(binoculars_scores < self.threshold,
                        "Most likely AI-generated",
                        "Most likely human-generated"
                        ).tolist()
        if verbose == True:
          print("Prediction (predict):", pred)
        return pred

print(torch.cuda.is_available())
np.set_printoptions(formatter={'float_kind':'{:f}'.format})
ce_loss_fn = torch.nn.CrossEntropyLoss(reduction="none")
softmax_fn = torch.nn.Softmax(dim=-1)
#initialize detector
bino = Binoculars()
# Current memory allocated by tensors
print("Allocated Memory:", torch.cuda.memory_allocated() / 1e9, "GB")

# Total memory reserved by PyTorch (includes cached memory)
print("Reserved Memory:", torch.cuda.memory_reserved() / 1e9, "GB")

import pandas as pd
torch.cuda.empty_cache()
raid_strings = pd.read_csv("/content/raid_test_5000.csv")
raid_4000 = raid_strings.iloc[:4000].copy()

def get_cross_perplexity_distribution_v3(input_string, model_p, model_q, tokenizer, pad_token_id, temperature=1.0, device='cuda:0'):
    # Tokenize the input
    encoding = tokenizer(input_string, return_tensors="pt", padding=True, truncation=True)
    input_ids = encoding['input_ids'].to(device)  # Move to device
    attention_mask = encoding['attention_mask'].to(device)  # Move to device

    # Get logits from both models
    logits_p = model_p(input_ids=input_ids, attention_mask=attention_mask).logits.to(device)
    logits_q = model_q(input_ids=input_ids, attention_mask=attention_mask).logits.to(device)

    # Shift logits to align with next-token prediction
    logits_q_shifted = logits_q[:, :-1, :] / temperature
    logits_p_shifted = logits_p[:, :-1, :] / temperature
    labels_shifted = input_ids[:, 1:]
    mask_shifted = attention_mask[:, 1:]

    # Token-wise Perplexity (Numerator) - Align with Binoculars' `perplexity`
    shifted_ce_loss = ce_loss_fn(logits_q_shifted.transpose(1, 2), labels_shifted)  # Cross-entropy loss per token
    token_perplexity = shifted_ce_loss * mask_shifted  # Mask padding tokens

    # Aggregate Perplexity (Sequence-Level)
    avg_perplexity = token_perplexity.sum(1) / mask_shifted.sum(1)

    # Token-wise Entropy (Denominator) - Align with Binoculars' `entropy`
    p_proba = F.softmax(logits_p_shifted, dim=-1)
    q_scores = logits_q_shifted  # Already shifted
    cross_entropy = ce_loss_fn(input=q_scores.view(-1, q_scores.size(-1)), target=p_proba.view(-1, p_proba.size(-1)))
    cross_entropy = cross_entropy.view(q_scores.size(0), -1)  # Reshape back to (batch_size, seq_len)
    token_entropy = cross_entropy * mask_shifted  # Mask padding tokens

    # Aggregate Entropy (Sequence-Level)
    avg_entropy = token_entropy.sum(1) / mask_shifted.sum(1)

    # Token-wise Cross-Perplexity
    token_cross_perplexity = token_perplexity / (token_entropy + 1e-8)  # Avoid division by zero

    # Sequence-Level Cross-Perplexity
    avg_cross_perplexity = avg_perplexity / avg_entropy

    # Convert to CPU and NumPy
    token_cross_perplexity_np = token_cross_perplexity.float().cpu().detach().numpy()
    avg_cross_perplexity_np = avg_cross_perplexity.float().cpu().detach().numpy()


    return token_cross_perplexity_np, avg_cross_perplexity_np

from tqdm import tqdm
# TODO: batching/aggregation possible? (not currently necessary but might be for larger dataset)
# compare avg crossplex to accuracy and fpr threshold to get result before plugging into
# raid results to get accuracy metric -- should be roughly 80%
token_cross_perplexity_list = []
avg_cross_perplexity_list = []
for text in tqdm(raid_4000['generation']):
  token_cross_perplexity, avg_cross_perplexity = get_cross_perplexity_distribution_v3(
      text,
      bino.observer_model,
      bino.performer_model,
      bino.tokenizer,
      bino.tokenizer.pad_token_id,
      device='cuda:0'
  )
  token_cross_perplexity_list.append(token_cross_perplexity)
  avg_cross_perplexity_list.append(avg_cross_perplexity)

pkl.dump(token_cross_perplexity_list, open('token_cross_perplexity.pkl', 'wb'))
  pkl.dump(avg_cross_perplexity_list, open('avg_cross_perplexity.pkl', 'wb'))

from google.colab import files
files.download('token_cross_perplexity.pkl')
files.download('avg_cross_perplexity.pkl')

cplex_flat = [x.squeeze() for x in token_cross_perplexity_list]
avg_flat = [x.squeeze() for x in avg_cross_perplexity_list]

def array_to_full_string(arr):
    # doing this because we need to remove ellipses -- pandas truncates the values without
    # a function to prevent this
    return "[" + " ".join(str(x) for x in arr) + "]"

raid_4000['token_cross_perplexity'] = [json.dumps(row.tolist()) for row in cplex_flat]
raid_4000['avg_cross_perplexity'] = avg_flat

# compare crossplex value to RAID threshold
raid_4000['prediction'] = raid_4000['avg_cross_perplexity'].apply(lambda x: 'AI' if x < BINOCULARS_ACCURACY_THRESHOLD else 'human')
# check if human == human and ai == ai (of some kind)
raid_4000['ground_truth'] = raid_4000.apply(lambda x: 1 if x['prediction'] == 'human' and x['model'] == 'human' or x['prediction'] != 'human' and x['model'] != 'human' else 0, axis=1)
# average value should equal accuracy %
raid_4000.loc[:, 'ground_truth'].mean()

# check before writing to output
raid_4000.head()

# write to output
raid_4000.to_csv('/content/raid_4000_with_scores_json.csv', index=False)

raid_4000 = pd.read_csv('/content/raid_4000_with_scores_json.csv')

files.download('/content/raid_4000_with_scores_json.csv')

